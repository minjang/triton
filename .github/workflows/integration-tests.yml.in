# integration-tests.yml.in is used to generate integration-tests.yml by
# expanding yaml anchors, because github actions don't support them
# (https://github.com/actions/runner/issues/1182).  pre-commit will do this for
# you automatically.


name: Integration Tests

on:
  workflow_dispatch:
  pull_request:
    # You can name your branch dev-foo to get CI runs.
    branches: [main, 'dev-**']
  merge_group:
    branches: [main, 'dev-**']
    types: [checks_requested]
  push:
    branches: [main]

concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

permissions: read-all

env:
  TRITON_BUILD_WITH_CLANG_LLD: "TRUE"
  TRITON_USE_ASSERT_ENABLED_LLVM: "TRUE"
  TRITON_DISABLE_LINE_INFO: 1

jobs:
  Runner-Preparation:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      matrix-CUDA: ${{ steps.set-matrix.outputs.matrix-CUDA }}
      matrix-HIP: ${{ steps.set-matrix.outputs.matrix-HIP }}
    steps:
      - name: Decide pre-submit integration test enablement
        # Always enable integration tests for pre-submit pull requests.
        if: github.event_name == 'pull_request'
        run: |
          echo "enable_integration=true" >> $GITHUB_ENV

      - name: Checkout post-submit commits
        if: github.event_name == 'push'
        uses: actions/checkout@v4
        with:
          # Only fetch two commits to check the latest changed files.
          fetch-depth: 2

      - name: Detect if build deps (e.g. LLVM hash) changed
        id: detect-change
        if: github.event_name == 'push'
        uses: tj-actions/changed-files@v44
        with:
          files: |
            cmake/*.txt

      - name: Detect if enough time has passed since last post-submit run
        id: detect-time
        if: github.event_name == 'push'
        run: |
          GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}
          REPO_NAME="${{ github.repository }}"
          # ID of integration-tests workflow
          WORKFLOW_ID="11678186"

          # Get the jobs URL for each instance of this workflow that completed successfully <4hr ago.
          JOBS_URLS=$(curl -s \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/openai/triton/actions/workflows/$WORKFLOW_ID/runs?branch=main&status=success&event=push&created=<$(date -u -Iseconds -d '4 hours ago')" \
            | jq -r '.workflow_runs[].jobs_url')

          GOT_SUCCESS="false"
          for URL in $JOBS_URLS; do
            echo "Considering $URL"
            STATUS=$(\
              curl -s \
                -H "Authorization: token $GITHUB_TOKEN" \
                -H "Accept: application/vnd.github.v3+json" \
                "$URL" \
              | jq -r '.jobs[] | select(.name=="Runner-Preparation") | .steps[]
                    | select(.name | contains("run integration tests")) | .conclusion')
            echo "Status is $STATUS"
            if [[ $STATUS == "success" ]]; then
              GOT_SUCCESS="true"
              break
            fi
          done

          # Did any of the aforementioned steps succeed?  If so, skip the build.
          #if [[ "$CONCLUSIONS" == *"success"* ]]; then
          if [[ "$GOT_SUCCESS" == "true" ]]; then
            echo "Will run CI; last build was long enough ago."
            echo "n_hours_since_last_run=true" >> $GITHUB_ENV
          else
            echo "Will not run CI; last build was too recent."
            echo "n_hours_since_last_run=false" >> $GITHUB_ENV
          fi

      # We want to run integration tests on the main branch (i.e. post-submit)
      # occasionally, because pre-submit CI caches will only read from caches
      # generated from the main branch (or the PR's branch), and we want these
      # caches to be recent.
      #
      # But we also don't want to run the tests on *every* commit, because this
      # would compete for resources with pre-commit CI (and the whole point of
      # caching is to speed up CI).
      #
      # As a compromise, run every N hours, or if a build dependency changes
      # (e.g.  we update the LLVM hash).
      #
      # Note: The name here is load-bearing; elsewhere in this file we use the
      # success of a step with this name to establish that we kicked off CI on
      # branch `main`.
      - name: Decide whether to run integration tests post-submit
        if: |
          github.event_name == 'push' &&
          (steps.detect-change.outputs.any_changed == 'true' ||
           env.n_hours_since_last_run == 'true')
        run: |
          echo "enable_integration=true" >> $GITHUB_ENV

      - name: Prepare runner matrix
        id: set-matrix
        if: env.enable_integration == 'true'
        run: |
          if [ x"${{ github.repository }}" == x"openai/triton" ]; then
            echo '::set-output name=matrix-CUDA::[["self-hosted", "A100"], ["self-hosted", "H100"]]'
            echo '::set-output name=matrix-HIP::[["self-hosted", "gfx90a"]]'
          else
            echo '::set-output name=matrix-CUDA::["ubuntu-latest"]'
            echo '::set-output name=matrix-HIP::["ubuntu-latest"]'
          fi

  pre-commit:
    name: pre-commit (code formatting)
    needs: Runner-Preparation
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Compute hash of pre-commit config
        id: cache-key
        run: |
          echo "pre_commit_hash=$(sha256sum .pre-commit-config.yaml)" >> $GITHUB_OUTPUT
        shell: bash

      - name: Cache pre-commit's cache dir
        uses: actions/cache@v4
        with:
          # Note that we cannot use environment variables here given there is
          # no shell to interpret them in the paths.
          path: |
            ~/.cache/pre-commit
          key: ${{ runner.os }}-${{ steps.cache-key.outputs.pre_commit_hash }}

      - name: Check pre-commit
        run: |
          python3 -m pip install --upgrade pre-commit
          # TODO: ignore the first yapf failure until https://github.com/google/yapf/issues/1164 is fixed
          python3 -m pre_commit run --all-files --verbose yapf &> /dev/null || true
          # If first run of yapf worked and made changes reset the tree to the original state
          git reset --hard
          python3 -m pre_commit run --all-files --verbose

      - name: Print diff of changes if pre-commit failed
        if: failure()
        run: |
          git diff

  Integration-Tests:
    needs: Runner-Preparation
    if: needs.Runner-Preparation.outputs.matrix-CUDA != ''

    runs-on: ${{ matrix.runner }}
    timeout-minutes: 30

    strategy:
      matrix:
        runner: ${{fromJson(needs.Runner-Preparation.outputs.matrix-CUDA)}}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: "true"

      - name: Install apt dependencies
        run: |
          sudo apt-get update -y
          sudo apt-get install -y ccache clang lld

      - name: Update PATH
        run: |
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Install pip dependencies
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install wheel cmake==3.24 ninja pytest-xdist lit

      - &compute-cache-keys-step
        name: Compute cache keys
        id: cache-key
        run: |
          echo "llvm=$(cat cmake/llvm-hash.txt | cut -c 1-8)" >> $GITHUB_OUTPUT
          echo "pybind11=$(cat cmake/pybind11-version.txt)" >> $GITHUB_OUTPUT
          echo "nvidia=$(cat cmake/nvidia-toolchain-version.txt)" >> $GITHUB_OUTPUT
          echo "datetime=$(date -u -Iseconds)" >> $GITHUB_OUTPUT
        shell: bash

      - &cache-build-dependencies-step
        name: Cache build dependencies
        uses: actions/cache@v4
        with:
          # Note that we cannot use environment variables here given there is
          # no shell to interpret them in the paths.
          path: |
            ~/.triton/llvm
            ~/.triton/nvidia
            ~/.triton/pybind11
          key: ${{ runner.os }}-${{ runner.arch }}-llvm-${{ steps.cache-key.outputs.llvm }}-nvidia-${{ steps.cache-key.outputs.nvidia }}-pybind11-${{ steps.cache-key.outputs.pybind11 }}

      # Cache ~/.triton/cache because the vast majority of unit test time is
      # spent compiling.  Triton won't (well, should not) use these cached files
      # if something internal to Triton changes, because Triton's internal
      # source code is part of the cache key.
      #
      # Similarly, cache ~/.cache/ccache to speed up compilation.
      #
      # On branch `main` we always start from an empty cache, i.e. we skip the
      # "restore" step.  This is to prevent the caches from accumulating stale
      # files over time.
      - &restore-build-artifacts-step
        name: Restore cache of ccache and Triton compilation artifacts
        if: github.event_name != 'push'
        uses: actions/cache/restore@v4
        with:
          path: |
            ~/.triton/cache
            ~/.cache/ccache
          # Restore the most recent cache entry.
          restore-keys: triton-artifacts-${{ runner.os }}-${{ runner.arch }}-${{ matrix.runner[1] }}-llvm-${{ steps.cache-key.outputs.llvm }}-
          # We expect this cache key never to hit and for us to fall back
          # unconditionally to the restore-key, so it doesn't actually matter
          # what we put here (so long as it doesn't hit an existing key).
          key: triton-artifacts-${{ runner.os }}-${{ runner.arch }}-${{ matrix.runner[1] }}-llvm-${{ steps.cache-key.outputs.llvm }}-${{ steps.cache-key.outputs.datetime }}

      - &inspect-cache-directory-step
        name: Inspect cache directory
        run: |
          mkdir -p ~/.triton
          ls -alh ~/.triton
          du -h --max-depth=1 ~/.triton

          if [ -x "$(command -v ccache)" ]; then
            ccache --zero-stats
          fi

      - name: Install Triton
        env:
          TRITON_BUILD_PROTON: "true"
          TRITON_BUILD_WITH_CCACHE: "true"
          CUDA_HOME: "/usr/local/cuda"
        run: |
          echo "PATH is '$PATH'"
          cd python
          python3 -m pip install --no-build-isolation -vvv '.[tests]'

      - &run-lit-tests-step
        name: Run lit tests
        run: |
          cd python
          LIT_TEST_DIR="build/$(ls build | grep -i cmake)/test"
          if [ ! -d "${LIT_TEST_DIR}" ]; then
            echo "Coult not find '${LIT_TEST_DIR}'" ; exit -1
          fi
          lit -v "${LIT_TEST_DIR}"

      - name: Run python tests on CUDA
        run: |
          cd python/test/unit
          python3 -m pytest -vvv -n 8 --ignore=hopper/test_flashattention.py --ignore=runtime --ignore=language/test_line_info.py --ignore=language/test_subprocess.py
          python3 -m pytest -vvv -n 8 language/test_subprocess.py
          # Run runtime tests serially to avoid race condition with cache handling
          python3 -m pytest -vvv runtime/
          # Run test_line_info.py separately with TRITON_DISABLE_LINE_INFO=0
          TRITON_DISABLE_LINE_INFO=0 python3 -m pytest -vvv language/test_line_info.py
          # Run hopper/test_flashattention.py separately to avoid out of gpu memory
          python3 -m pytest -vs hopper/test_flashattention.py

      - name: Run interpreter tests
        if: ${{matrix.runner[0] == 'self-hosted' && matrix.runner[1] == 'H100'}}
        env:
          TRITON_INTERPRET: "1"
        run: |
          cd python/test/unit
          python3 -m pytest -vvv -n 16 -m interpreter language/test_core.py language/test_standard.py \
           language/test_random.py language/test_block_pointer.py operators/test_flash_attention.py::test_op \
           --device cpu

      - &run-cpp-unittests-step
        name: Run C++ unittests
        run: |
          cd python
          cd "build/$(ls build | grep -i cmake)"
          ctest

      - name: Run Proton tests
        env:
          LD_LIBRARY_PATH: "/usr/local/cuda/extras/CUPTI/lib64:$LD_LIBRARY_PATH"
        run: |
          cd third_party/proton
          python3 -m pytest -vvv test

      # Save the ccache Triton compilation artifacts to the cache so they can be
      # used by other CI runs.
      #
      # If we're on branch main, this cache can be used by any branch.  OTOH if
      # we're on a PR's branch, this cache can only be used by future pushes
      # from that PR.  This is still useful, because most PRs run CI more than
      # once.  Github expires caches LRU, so the cache from `main` should not
      # get evicted (unless we have a ton of PRs in progress without any new
      # ones being made).
      - &save-build-artifacts-step
        name: Save ccache and Triton compilation artifacts to cache
        uses: actions/cache/save@v4
        with:
          path: |
            ~/.triton/cache
            ~/.cache/ccache
          key: triton-artifacts-${{ runner.os }}-${{ runner.arch }}-${{ matrix.runner[1] }}-llvm-${{ steps.cache-key.outputs.llvm }}-${{ steps.cache-key.outputs.datetime }}

      - &inspect-cache-directories-step
        name: Inspect cache directories
        run: |
          mkdir -p ~/.triton
          ls -alh ~/.triton
          du -h --max-depth=1 ~/.triton

          mkdir -p ~/.cache/ccache
          du -sh ~/.cache/ccache

          if [ -x "$(command -v ccache)" ]; then
            ccache --show-stats
          fi

  Integration-Tests-AMD:
    needs: Runner-Preparation
    if: needs.Runner-Preparation.outputs.matrix-HIP != ''

    runs-on: ${{ matrix.runner }}
    timeout-minutes: 30

    strategy:
      matrix:
        runner: ${{fromJson(needs.Runner-Preparation.outputs.matrix-HIP)}}

    container:
      image: rocm/pytorch:rocm6.0.2_ubuntu22.04_py3.10_pytorch_2.1.2
      options: --device=/dev/kfd --device=/dev/dri --security-opt seccomp=unconfined --group-add video --user root

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: 'true'

      - *compute-cache-keys-step
      - *cache-build-dependencies-step

      # Don't save/restore build artifacts on AMD.  Even in the 100% cache hit
      # case, there seems to be no speedup.  Perhaps the C++ build is
      # nondeterministic so we don't get cache hits, or perhaps there's some
      # other problem.
      #
      # No cache: https://github.com/openai/triton/actions/runs/8754816940/job/24027526029
      # Cache: https://github.com/openai/triton/actions/runs/8754623461/job/24026850886
      #
      # TODO(antiagainst): Enable this caching on AMD.
      #
      #- *restore-build-artifacts-step

      - *inspect-cache-directory-step

      - name: Update PATH
        run: |
          echo "/opt/rocm/llvm/bin" >> $GITHUB_PATH

      - name: Install pip dependencies
        run: |
          python3 -m pip install lit

      - name: Install Triton
        run: |
          echo "PATH is '$PATH'"
          pip uninstall -y triton
          cd python
          pip install -v -e .

      - *run-lit-tests-step

      - name: Run python tests on HIP
        run: |
          pytest --capture=tee-sys -rfs -vvv python/tutorials/06-fused-attention.py
          cd python/test/unit
          pytest --capture=tee-sys -rfs -vvv -n 32 language operators \
                 hopper/test_mixed_io.py \
                 hopper/test_gemm.py \
                 hopper/test_tma_store_gemm.py \
                 hopper/test_persistent_warp_specialized_fused-attention.py \
                 --ignore=language/test_conversions.py \
                 --ignore=language/test_line_info.py
          # Run test_line_info.py separately with TRITON_DISABLE_LINE_INFO=0
          TRITON_DISABLE_LINE_INFO=0 python3 -m pytest -vvv -n 8 language/test_line_info.py

          # Run runtime tests serially to avoid race condition with cache handling
          python3 -m pytest -vvv runtime

      - *run-cpp-unittests-step

      # Don't build artifacts on AMD; it doesn't help.  (See commented-out
      # restore-build-artifacts-step.)
      #
      #- *save-build-artifacts-step

      - *inspect-cache-directories-step
